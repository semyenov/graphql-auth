---
description: 
globs: 
alwaysApply: false
---
# FetchDTS Type Safety Patterns

## Overview
This project uses fetchdts for enhanced HTTP and API type safety. The types are imported from the generated types in `node_modules/fetchdts/dist/index.d.mts`.

## Key Type Imports
Always import these types from fetchdts when working with HTTP operations:

```typescript
import type { 
  Endpoint, 
  TypedRequest,
  TypedHeaders,
  RequestHeaders,
  ResponseHeaders,
  HTTPMethod,
  MimeType,
  TypedFetchInput,
  TypedFetchRequestInit,
  TypedFetchResponseBody
} from 'fetchdts'
```

## GraphQL API Schema Pattern
Define your API schema using the fetchdts `Endpoint` symbol pattern:

```typescript
export interface GraphQLAPISchema {
  '/graphql': {
    [Endpoint]: {
      POST: {
        body: GraphQLRequestBody
        headers: {
          'content-type': 'application/json'
          authorization?: string
        }
        response: GraphQLResponse
        responseHeaders: {
          'content-type': 'application/json'
        }
      }
    }
  }
}
```

## Context Enhancement Pattern
See [src/context.ts](mdc:src/context.ts) for the enhanced context pattern:

- Use `HTTPMethod` type for request methods
- Use `MimeType` type for content types
- Create structured context interfaces with proper typing
- Implement type-safe request helpers using fetchdts types

## Apollo Server Integration
See [src/server.ts](mdc:src/server.ts) for Apollo Server integration:

- Use `GraphQLRequestContext` and `GraphQLRequestListener` for plugins
- Leverage fetchdts types in logging and error handling
- Type-safe error formatting with `GraphQLFormattedError`
- Structured logging with HTTP method and content type information

## Best Practices
1. Always use fetchdts types for HTTP-related operations
2. Create schema interfaces using the `Endpoint` symbol
3. Leverage TypeScript's strict typing with fetchdts for better developer experience
4. Use structured logging with fetchdts types for better debugging
