---
description: 
globs: 
alwaysApply: false
---
# Development Workflow Guide

## Getting Started
This project uses Bun as the JavaScript runtime for better performance and developer experience.

### Prerequisites
- Bun installed (`curl -fsSL https://bun.sh/install | bash`)
- Node.js 18+ (for compatibility)
- TypeScript knowledge
- GraphQL familiarity

### Setup Commands
```bash
# Install dependencies
bun install

# Generate GraphQL schema
bun run generate

# Start development server
bun run dev

# Build for production
bun run build

# Start production server
bun run start
```

## Development Server
The development server runs on `http://localhost:4000` with the following endpoints:
- `http://localhost:4000/graphql` - GraphQL endpoint
- `http://localhost:4000/graphql` - GraphQL Playground (development)

## Type Safety Development Flow

### 1. GraphQL Schema First
- Define mutations and queries in [src/context.ts](mdc:src/context.ts) using GraphQL Tada
- Use the `graphql()` template literal for type-safe operations
- Export both `ResultOf` and `VariablesOf` types for each operation

### 2. API Schema Definition
- Define API schemas using fetchdts `Endpoint` pattern
- Include proper request/response typing
- Specify headers and content types explicitly

### 3. Context Enhancement
- Leverage the enhanced context from [src/context.ts](mdc:src/context.ts)
- Use fetchdts types for HTTP-level operations
- Implement type-safe request helpers

### 4. Server Configuration
- Extend the Apollo Server setup in [src/server.ts](mdc:src/server.ts)
- Add custom plugins for logging and error handling
- Use fetchdts types in server middleware

## Code Organization Best Practices

### File Structure
```
src/
├── server.ts          # Apollo Server setup with enhanced plugins
├── context.ts         # Type-safe GraphQL context with fetchdts
├── schema.ts          # GraphQL schema definition
├── builder.ts         # Pothos GraphQL schema builder
├── generate-schema.ts # Schema generation utilities
└── utils.ts           # Utility functions
```

### Import Patterns
Always organize imports in this order:
1. Node.js built-ins
2. Third-party libraries (Apollo, GraphQL, etc.)
3. fetchdts types
4. Local modules

```typescript
import { IncomingMessage } from 'http'
import { ApolloServer } from '@apollo/server'
import { graphql } from 'gql.tada'
import type { HTTPMethod, MimeType } from 'fetchdts'
import { Context, createContext } from './context'
```

## Testing Strategy

### Type Safety Testing
- Use TypeScript strict mode for compile-time error detection
- Leverage fetchdts types for API contract testing
- Test GraphQL operations with GraphQL Tada type inference

### Development Testing
- Use GraphQL Playground for interactive testing
- Test authentication flows with proper JWT tokens
- Validate error handling and logging patterns

## Environment Configuration

### Development Environment
- `NODE_ENV=development` for detailed error messages and stack traces
- Enhanced logging with operation details
- GraphQL Playground enabled
- CORS configured for development

### Production Environment
- `NODE_ENV=production` for sanitized error responses
- Structured logging without sensitive information
- Proper security headers
- Performance monitoring enabled

## Performance Considerations

### Bun Runtime Benefits
- Faster JavaScript execution
- Built-in TypeScript support
- Optimized package management
- Better memory usage

### GraphQL Optimizations
- Enable Apollo Server introspection caching
- Use structured logging to avoid performance overhead
- Implement proper error handling to prevent server crashes

## Security Best Practices

### Authentication Security
- Use JWT tokens for stateless authentication
- Implement proper token validation in context
- Use HTTPS in production environments
- Validate and sanitize all user inputs

### Error Handling Security
- Never expose internal error details in production
- Log all security-related events
- Implement rate limiting for authentication endpoints
- Use secure HTTP headers

## Debugging and Monitoring

### Development Debugging
- Use Consola structured logging for better debugging
- Enable GraphQL Playground for query testing
- Use TypeScript strict mode for early error detection
- Leverage fetchdts types for better IntelliSense

### Production Monitoring
- Implement comprehensive error logging
- Monitor GraphQL operation performance
- Track authentication success/failure rates
- Use structured logging for better log parsing

## Best Practices Summary
1. **Type Safety First**: Always use fetchdts and GraphQL Tada types
2. **Structured Logging**: Use Consola with structured objects
3. **Error Handling**: Implement comprehensive error handling patterns
4. **Security**: Validate inputs and sanitize error responses
5. **Performance**: Leverage Bun runtime optimizations
6. **Testing**: Use type-safe testing patterns with strong typing
7. **Documentation**: Keep Cursor Rules updated with code changes
