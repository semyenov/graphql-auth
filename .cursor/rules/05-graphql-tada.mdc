---
description: GraphQL Tada usage patterns for type-safe GraphQL operations
globs: ["src/gql/**/*.ts", "**/*.graphql"]
alwaysApply: false
---
# GraphQL Tada Usage Guide

## Overview

GraphQL Tada provides compile-time type safety for GraphQL operations. All typed operations are in the `src/gql/` directory.

## File Structure
```
src/gql/
├── client.ts          # GraphQL client setup
├── fragments.ts       # Reusable fragments
├── queries.ts         # Standard queries
├── mutations.ts       # Standard mutations
├── relay-queries.ts   # Relay-style queries
├── relay-mutations.ts # Relay-style mutations
└── types.d.ts         # Generated types
```

## Defining Operations

### Queries
```typescript
import { graphql } from '../graphql-env'

// Simple query
export const GetAllUsersQuery = graphql(`
  query GetAllUsers {
    allUsers {
      id
      name
      email
      posts {
        id
        title
        published
      }
    }
  }
`)

// Query with variables
export const GetPostQuery = graphql(`
  query GetPost($id: ID!) {
    post(id: $id) {
      id
      title
      content
      author {
        id
        name
      }
    }
  }
`)

// Query with fragments
export const GetUserWithPostsQuery = graphql(`
  query GetUserWithPosts($id: ID!) {
    user(id: $id) {
      ...UserFields
      posts {
        ...PostFields
      }
    }
  }
`, [UserFragment, PostFragment])
```

### Mutations
```typescript
// Authentication mutations
export const LoginMutation = graphql(`
  mutation Login($email: String!, $password: String!) {
    login(email: $email, password: $password)
  }
`)

export const SignupMutation = graphql(`
  mutation Signup($email: String!, $password: String!, $name: String) {
    signup(email: $email, password: $password, name: $name)
  }
`)

// CRUD mutations
export const CreateDraftMutation = graphql(`
  mutation CreateDraft($data: PostCreateInput!) {
    createDraft(data: $data) {
      id
      title
      content
      published
      author {
        id
        name
      }
    }
  }
`)
```

### Fragments
```typescript
// src/gql/fragments.ts
export const UserFragment = graphql(`
  fragment UserFields on User {
    id
    email
    name
  }
`)

export const PostFragment = graphql(`
  fragment PostFields on Post {
    id
    title
    content
    published
    viewCount
    createdAt
    updatedAt
  }
`)

// Relay-specific fragments
export const RelayPostFragment = graphql(`
  fragment RelayPostFields on Post {
    id
    title
    content
    published
    viewCount
    createdAt
    updatedAt
    author {
      id
      name
      email
    }
  }
`)
```

## Type Extraction

### Result Types
```typescript
import type { ResultOf } from '../graphql-env'

// Extract result type
export type GetAllUsersResult = ResultOf<typeof GetAllUsersQuery>
export type LoginResult = ResultOf<typeof LoginMutation>
export type CreateDraftResult = ResultOf<typeof CreateDraftMutation>

// Usage
function handleUsers(data: GetAllUsersResult) {
  data.allUsers.forEach(user => {
    console.log(user.name) // Type-safe!
  })
}
```

### Variable Types
```typescript
import type { VariablesOf } from '../graphql-env'

// Extract variable types
export type GetPostVariables = VariablesOf<typeof GetPostQuery>
export type LoginVariables = VariablesOf<typeof LoginMutation>
export type CreateDraftVariables = VariablesOf<typeof CreateDraftMutation>

// Usage
const variables: LoginVariables = {
  email: 'user@example.com',
  password: 'password123',
}
```

## Relay Patterns

### Connection Queries
```typescript
export const GetFeedQuery = graphql(`
  query GetFeed(
    $first: Int
    $after: ID
    $searchString: String
    $orderBy: PostOrderByUpdatedAtInput
  ) {
    feed(
      first: $first
      after: $after
      searchString: $searchString
      orderBy: $orderBy
    ) {
      edges {
        cursor
        node {
          ...RelayPostFields
        }
      }
      pageInfo {
        hasNextPage
        hasPreviousPage
        startCursor
        endCursor
      }
      totalCount
    }
  }
`, [RelayPostFragment])
```

### Node Queries
```typescript
export const GetPostQuery = graphql(`
  query GetPost($id: ID!) {
    post(id: $id) {
      ...RelayPostFields
    }
  }
`, [RelayPostFragment])
```

## Usage in Tests

### Import and Use
```typescript
import { print } from 'graphql'
import { LoginMutation, SignupMutation } from '../src/gql/relay-mutations'
import { GetFeedQuery, GetMeQuery } from '../src/gql/relay-queries'

// Execute operation
const result = await executeOperation(
  server,
  print(LoginMutation), // Convert to string
  { email: 'test@example.com', password: 'password' },
  context
)
```

### Type-Safe Test Helpers
```typescript
// Define response type
interface LoginResponse {
  login: string
}

// Use in test
const data = await gqlHelpers.expectSuccessfulMutation<LoginResponse>(
  server,
  print(LoginMutation),
  variables,
  context
)

expect(data.login).toBeDefined()
```

## Client Usage

### GraphQL Client Setup
```typescript
// src/gql/client.ts
import { fetchdts } from 'fetchdts'

const gqlClient = fetchdts('http://localhost:4000/graphql').create({
  headers: {
    'Content-Type': 'application/json',
  },
})

export async function executeGraphQL<TData, TVariables>(
  query: string,
  variables?: TVariables,
  token?: string
): Promise<TData> {
  const headers: Record<string, string> = {}
  if (token) {
    headers['Authorization'] = `Bearer ${token}`
  }
  
  const response = await gqlClient.post({
    body: { query, variables },
    headers,
  })
  
  if (response.errors) {
    throw new Error(response.errors[0].message)
  }
  
  return response.data
}
```

### Convenience Functions
```typescript
// Login helper
export async function login(
  email: string,
  password: string
): Promise<string> {
  const data = await executeGraphQL<LoginResult>(
    print(LoginMutation),
    { email, password }
  )
  return data.login
}

// Create post helper
export async function createDraft(
  title: string,
  content: string,
  token: string
): Promise<CreateDraftResult['createDraft']> {
  const data = await executeGraphQL<CreateDraftResult>(
    print(CreateDraftMutation),
    { data: { title, content } },
    token
  )
  return data.createDraft
}
```

## Best Practices

1. **Always define operations in src/gql/**
   - Keep all GraphQL operations centralized
   - Never write inline GraphQL strings

2. **Export type aliases**
   ```typescript
   export type MyQueryResult = ResultOf<typeof MyQuery>
   export type MyQueryVariables = VariablesOf<typeof MyQuery>
   ```

3. **Use fragments for reusable selections**
   ```typescript
   const UserWithPostsFragment = graphql(`
     fragment UserWithPosts on User {
       ...UserFields
       posts {
         ...PostFields
       }
     }
   `, [UserFields, PostFields])
   ```

4. **Print operations for execution**
   ```typescript
   import { print } from 'graphql'
   const queryString = print(MyQuery)
   ```

5. **Type your test assertions**
   ```typescript
   interface ExpectedResponse {
     myQuery: {
       id: string
       name: string
     }
   }
   
   const data = await executeOperation<ExpectedResponse>(...)
   expect(data.myQuery.name).toBe('Expected')
   ```

## Common Patterns

### Pagination
```typescript
// First page
const firstPage = await executeGraphQL<GetFeedResult>(
  print(GetFeedQuery),
  { first: 10 }
)

// Next page
const nextPage = await executeGraphQL<GetFeedResult>(
  print(GetFeedQuery),
  { 
    first: 10, 
    after: firstPage.feed.pageInfo.endCursor 
  }
)
```

### Error Handling
```typescript
try {
  const data = await executeGraphQL<LoginResult>(
    print(LoginMutation),
    { email, password }
  )
  return data.login
} catch (error) {
  if (error.message.includes('Invalid credentials')) {
    throw new AuthenticationError()
  }
  throw error
}
```

## Regenerating Types

When the schema changes:

```bash
# Regenerate GraphQL types
bun run generate:gql

# Or regenerate everything
bun run generate
```

This updates the introspection file and TypeScript types.