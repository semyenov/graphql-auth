<!-- Generated by SpecStory -->

# From Background: Enhance type safety and code quality (2025-06-15 20:11:57)

_**User**_

enhance typesafety and code quality

---

_**Assistant**_



---

I'll help you enhance the type safety and code quality of your GraphQL TypeScript project. Let me first examine the current codebase structure and then implement improvements.

---

<details>
            <summary>Listed directory undefined ‚Ä¢ **18** results</summary>
        
| Name |
|-------|
| üìÅ `.git` |
| üìÑ `bun.lock` |
| üìÑ `package.json` |
| üìÅ `prisma` |
| üìÑ `schema.graphql` |
| üìÅ `src` |
| üìÑ `tsconfig.json` |
| üìÅ `types` |
| üìÑ `.cursorindexingignore` |
| üìÑ `.gitignore` |
| üìÅ `.specstory` |
| üìÅ `.vscode` |
| üìÑ `CLAUDE.md` |
| üìÑ `README.md` |
| üìÑ `README.template.md` |
| üìÑ `SETUP.md` |
| üìÅ `_docs` |
| üìÅ `.cursor` |

</details>

---



---

<details>
            <summary>Listed directory undefined ‚Ä¢ **9** results</summary>
        
| Name |
|-------|
| üìÑ `builder.ts` |
| üìÑ `context.ts` |
| üìÑ `generate-schema.ts` |
| üìÑ `graphql-env.d.ts` |
| üìÅ `permissions` |
| üìÑ `prisma.ts` |
| üìÑ `schema.ts` |
| üìÑ `server.ts` |
| üìÑ `utils.ts` |

</details>

---

Read file: package.json

---

Read file: tsconfig.json

---

_**User**_

Sorry for the interruption. Please continue.

---

_**Assistant**_



---

Read file: src/schema.ts

---



---

Read file: src/generate-schema.ts

---



---

<details>
            <summary>Listed directory undefined ‚Ä¢ **1** results</summary>
        
| Name |
|-------|
| üìÑ `index.ts` |

</details>

---



---

Read file: src/permissions/index.ts

---



---

<details>
            <summary>Listed directory undefined ‚Ä¢ **3** results</summary>
        
| Name |
|-------|
| üìÅ `migrations` |
| üìÑ `schema.prisma` |
| üìÑ `seed.ts` |

</details>

---



---

Read file: prisma/schema.prisma

---



---

Now I'll implement comprehensive type safety and code quality improvements. Let me start by analyzing the current issues and implementing enhanced type definitions, error handling, and security improvements.

---

```diff
+ import type { User as PrismaUser, Post as PrismaPost } from '@prisma/client'
+ import type { GraphQLError } from 'graphql'
+ 
+ // Domain Types
+ export interface User extends Omit<PrismaUser, 'password'> {
+   id: number
+   email: string
+   name: string | null
+   posts?: Post[]
+ }
+ 
+ export interface Post extends PrismaPost {
+   id: number
+   title: string
+   content: string | null
+   published: boolean
+   createdAt: Date
+   updatedAt: Date
+   viewCount: number
+   author?: User
+   authorId: number | null
+ }
+ 
+ // Authentication Types
+ export interface AuthPayload {
+   token: string
+   user: User
+ }
+ 
+ export interface JWTPayload {
+   userId: string
+   email: string
+   iat?: number
+   exp?: number
+ }
+ 
+ // Input Types with validation
+ export interface SignupInput {
+   email: string
+   password: string
+   name?: string
+ }
+ 
+ export interface LoginInput {
+   email: string
+   password: string
+ }
+ 
+ export interface PostCreateInput {
+   title: string
+   content?: string
+ }
+ 
+ export interface PostUpdateInput {
+   title?: string
+   content?: string
+   published?: boolean
+ }
+ 
+ export interface UserUniqueInput {
+   id?: number
+   email?: string
+ }
+ 
+ export interface PostOrderByInput {
+   updatedAt?: 'asc' | 'desc'
+   createdAt?: 'asc' | 'desc'
+   viewCount?: 'asc' | 'desc'
+ }
+ 
+ export interface FeedInput {
+   searchString?: string
+   skip?: number
+   take?: number
+   orderBy?: PostOrderByInput
+ }
+ 
+ // Error Types
+ export enum ErrorCode {
+   AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
+   AUTHORIZATION_ERROR = 'AUTHORIZATION_ERROR',
+   VALIDATION_ERROR = 'VALIDATION_ERROR',
+   NOT_FOUND = 'NOT_FOUND',
+   INTERNAL_ERROR = 'INTERNAL_ERROR',
+   DUPLICATE_ERROR = 'DUPLICATE_ERROR',
+   NETWORK_ERROR = 'NETWORK_ERROR'
+ }
+ 
+ export interface AppError {
+   code: ErrorCode
+   message: string
+   field?: string
+   details?: Record<string, unknown>
+ }
+ 
+ export interface ValidationError extends AppError {
+   code: ErrorCode.VALIDATION_ERROR
+   field: string
+   value?: unknown
+ }
+ 
+ // Result Types for better error handling
+ export type Result<T, E = AppError> = 
+   | { success: true; data: T }
+   | { success: false; error: E }
+ 
+ // Environment Types
+ export interface EnvironmentConfig {
+   NODE_ENV: 'development' | 'production' | 'test'
+   PORT: number
+   HOST: string
+   APP_SECRET: string
+   DATABASE_URL: string
+   CORS_ORIGIN?: string
+   LOG_LEVEL?: 'debug' | 'info' | 'warn' | 'error'
+ }
+ 
+ // Context Enhancement Types
+ export interface RequestMetadata {
+   ip?: string
+   userAgent?: string
+   operationName?: string
+   query?: string
+   variables?: Record<string, unknown>
+   startTime: number
+ }
+ 
+ // Utility Types
+ export type NonNullable<T> = T extends null | undefined ? never : T
+ 
+ export type OptionalFields<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>
+ 
+ export type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>
+ 
+ // Pagination Types
+ export interface PaginationInput {
+   skip?: number
+   take?: number
+ }
+ 
+ export interface PaginatedResult<T> {
+   nodes: T[]
+   totalCount: number
+   hasNextPage: boolean
+   hasPreviousPage: boolean
+ }
+ 
+ // Response Types for GraphQL operations
+ export interface MutationResponse<T = unknown> {
+   success: boolean
+   data?: T
+   error?: AppError
+ }
+ 
+ // Logging Types
+ export interface LogMetadata {
+   requestId?: string
+   userId?: number
+   operationName?: string
+   duration?: number
+   error?: Error | GraphQLError
+   [key: string]: unknown
+ }
+ 
+ // Security Types
+ export interface SecurityContext {
+   isAuthenticated: boolean
+   userId?: number
+   userEmail?: string
+   roles?: string[]
+   permissions?: string[]
+ }
```

---



---

```diff
- import type { Post as PrismaPost, User as PrismaUser } from '@prisma/client'
+ import type { User as PrismaUser, Post as PrismaPost } from '@prisma/client'
  import type { GraphQLError } from 'graphql'
  
  // Domain Types
```

---



---

```bash
cd /workspace && bun run generate:prisma
```

```
workspace $workspace $ cd /workscd /workspace && bun run generate:prisma
bash: bun: command not found
workspace $
```

---



---

```bash
npx prisma generate
```

```
workspace $workspace $ npx prisma generate
‚†∏workspace $ npx prisma generate
‚†èworkspace $ npx prisma generate
‚†∏workspace $ npx prisma generate
‚†èworkspace $ npx prisma generate
‚†¥workspace $ npx prisma generate
‚†ãworkspace $ npx prisma generate
‚†¶workspace $ npx prisma generateworkspace $ npx prisma generate
Prisma schema loaded from prisma/schema.prismaworkspace $ npx prisma generate
Prisma schema loaded from prisma/schema.prisma

‚úî Installed the @prisma/client and prisma packages in your project
Error: Generator "prisma-pothos-types" failed:

/bin/sh: 1: prisma-pothos-types: not found

workspace $
```

---



---

```bash
npm install prisma-pothos-types --save-dev
```

```
workspace $workspace $ npm instanpm install prisma-pothos-types --save-dev
npm error code E404
npm error 404 Not Found - GET https://registry.npmjs.org/prisma-pothos-types - N
ot found
npm error 404
npm error 404  'prisma-pothos-types@*' is not in this registry.
npm error 404
npm error 404 Note that you can also install from a
npm error 404 tarball, folder, http url, or git url.
npm error A complete log of this run can be found in: /home/ubuntu/.npm/_logs/20
25-06-15T17_06_16_569Z-debug-0.log
workspace $
```

---



---

<details>
            <summary>Searched web "undefined" ‚Ä¢ **6** results</summary>
        
| Title | URL |
|-------|-----|
| pothos/plugin-prisma | https://www.npmjs.com/package/@pothos/plugin-prisma |
| pothos/plugin-prisma-utils | https://www.npmjs.com/package/%40pothos%2Fplugin-prisma-utils |
| Generators (Reference) \| Prisma Documentation | https://www.prisma.io/docs/orm/prisma-schema/overview/generators |
| GitHub - Cauen/prisma-generator-pothos-codegen: The fastest way to create a fully customizable CRUD Graphql API from Prisma Schema. | https://github.com/Cauen/prisma-generator-pothos-codegen |
| @mainamiru/prisma-types-generator | https://www.npmjs.com/package/@mainamiru/prisma-types-generator |
| prisma-generator-typescript-interfaces | https://www.npmjs.com/package/prisma-generator-typescript-interfaces |

</details>

---



---



---



---

Read file: prisma/schema.prisma

---



---

```bash
npm install @pothos/plugin-prisma prisma-pothos-types --save-dev
```

```
workspace $npm warn idealTree Removing dependencies.@pothos/plugin-prisma in favor of devDe
pendencies.@pothos/plugin-prisma
‚†ônpm warn idealTree Removing dependencies.@pothos/plugin-prisma in favor of devDe
pendencies.@pothos/plugin-prisma
‚†∏npm warn idealTree Removing dependencies.@pothos/plugin-prisma in favor of devDe
pendencies.@pothos/plugin-prisma
npm error code E404
npm error 404 Not Found - GET https://registry.npmjs.org/prisma-pothos-types - N
ot found
npm error 404
npm error 404  'prisma-pothos-types@*' is not in this registry.
npm error 404
npm error 404 Note that you can also install from a
npm error 404 tarball, folder, http url, or git url.
npm error A complete log of this run can be found in: /home/ubuntu/.npm/_logs/20
25-06-15T17_06_48_086Z-debug-0.log
workspace $
```

---



---

```bash
npm install @pothos/plugin-prisma/generator --save-dev
```

```
workspace $workspace $ npm instanpm install @pothos/plugin-prisma/generator --save-dev
npm error code ENOENT
npm error syscall open
npm error path /workspace/@pothos/plugin-prisma/generator/package.json
npm error errno -2
npm error enoent Could not read package.json: Error: ENOENT: no such file or dir
ectory, open '/workspace/@pothos/plugin-prisma/generator/package.json'
npm error enoent This is related to npm not being able to find a file.
npm error enoent
npm error A complete log of this run can be found in: /home/ubuntu/.npm/_logs/20
25-06-15T17_06_54_189Z-debug-0.log
workspace $
```

---



---

<details>
            <summary>Searched web "undefined" ‚Ä¢ **6** results</summary>
        
| Title | URL |
|-------|-----|
| pothos/plugin-prisma | https://www.npmjs.com/package/@pothos/plugin-prisma |
| pothos/plugin-prisma-utils | https://www.npmjs.com/package/%40pothos%2Fplugin-prisma-utils |
| Generators (Reference) \| Prisma Documentation | https://www.prisma.io/docs/orm/prisma-schema/overview/generators |
| GitHub - Cauen/prisma-generator-pothos-codegen: The fastest way to create a fully customizable CRUD Graphql API from Prisma Schema. | https://github.com/Cauen/prisma-generator-pothos-codegen |
| GitHub - YassinEldeeb/create-prisma-generator: Get started developing your own ‚ó≠ Prisma generator by running a single command. | https://github.com/YassinEldeeb/create-prisma-generator |
| GitHub - Kalissaac/prisma-typegen: Generates full types (including relations) for TypeScript from a Prisma schema | https://github.com/Kalissaac/prisma-typegen |

</details>

---



---

Now I understand the correct setup. The `prisma-pothos-types` generator comes built-in with the `@pothos/plugin-prisma` package, so I don't need to install a separate package. Let me continue with implementing the comprehensive type safety improvements.

---

```diff
+ import { z } from 'zod'
+ import type { EnvironmentConfig } from './types'
+ 
+ // Environment schema for validation
+ const EnvironmentSchema = z.object({
+   NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
+   PORT: z.string().regex(/^\d+$/).transform((val) => parseInt(val, 10)).default('4000'),
+   HOST: z.string().default('localhost'),
+   APP_SECRET: z.string().min(8, 'APP_SECRET must be at least 8 characters'),
+   DATABASE_URL: z.string().url('DATABASE_URL must be a valid URL'),
+   CORS_ORIGIN: z.string().optional(),
+   LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info')
+ })
+ 
+ // Parse and validate environment variables
+ function parseEnvironment(): EnvironmentConfig {
+   try {
+     const env = {
+       NODE_ENV: process.env.NODE_ENV,
+       PORT: process.env.PORT || '4000',
+       HOST: process.env.HOST || 'localhost',
+       APP_SECRET: process.env.APP_SECRET || 'appsecret321',
+       DATABASE_URL: process.env.DATABASE_URL || 'file:./dev.db',
+       CORS_ORIGIN: process.env.CORS_ORIGIN,
+       LOG_LEVEL: process.env.LOG_LEVEL || 'info'
+     }
+ 
+     return EnvironmentSchema.parse(env)
+   } catch (error) {
+     if (error instanceof z.ZodError) {
+       console.error('‚ùå Environment validation failed:')
+       error.errors.forEach((err) => {
+         console.error(`  ${err.path.join('.')}: ${err.message}`)
+       })
+       process.exit(1)
+     }
+     throw error
+   }
+ }
+ 
+ export const env = parseEnvironment()
+ 
+ export const isDevelopment = env.NODE_ENV === 'development'
+ export const isProduction = env.NODE_ENV === 'production'
+ export const isTest = env.NODE_ENV === 'test'
```

---



---

```bash
npm install zod
```

```
workspace $workspace $ npm install zod
‚†∏workspace $ npm install zod

added 1 package, and audited 224 packages in 482ms

19 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
workspace $
```

---



---

```diff
      "strict": true,
      "module": "ESNext",
      "target": "ESNext",
-     "lib": ["ESNext"],
+     "lib": ["ESNext", "DOM"],
      "moduleResolution": "bundler",
      "allowJs": true,
      "skipLibCheck": true,
```

```diff
      "noFallthroughCasesInSwitch": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
-     "types": ["bun"],
+     "types": ["bun", "node"],
      "typeRoots": [
        "./node_modules/@types", 
        "./.specstory/types",
```

---



---

```bash
npm install @types/node --save-dev
```

```
workspace $workspace $ npm instanpm install @types/node --save-dev

up to date, audited 224 packages in 427ms

19 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
workspace $
```

---



---

```diff
  
  // Environment schema for validation
  const EnvironmentSchema = z.object({
-   NODE_ENV: z
-     .enum(['development', 'production', 'test'])
-     .default('development'),
-   PORT: z
-     .string()
-     .regex(/^\d+$/)
-     .transform((val) => parseInt(val, 10))
-     .default('4000'),
+   NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
+   PORT: z.string().regex(/^\d+$/).transform((val: string) => parseInt(val, 10)).default('4000'),
    HOST: z.string().default('localhost'),
    APP_SECRET: z.string().min(8, 'APP_SECRET must be at least 8 characters'),
    DATABASE_URL: z.string().url('DATABASE_URL must be a valid URL'),
    CORS_ORIGIN: z.string().optional(),
-   LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
+   LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info')
  })
  
  // Parse and validate environment variables
```

```diff
        APP_SECRET: process.env.APP_SECRET || 'appsecret321',
        DATABASE_URL: process.env.DATABASE_URL || 'file:./dev.db',
        CORS_ORIGIN: process.env.CORS_ORIGIN,
-       LOG_LEVEL: process.env.LOG_LEVEL || 'info',
+       LOG_LEVEL: process.env.LOG_LEVEL || 'info'
      }
  
      return EnvironmentSchema.parse(env)
```

---



---

```diff
+ import { z } from 'zod'
+ import type { AppError, ErrorCode, ValidationError, Result } from './types'
+ 
+ // Create a custom app error
+ export function createAppError(
+   code: ErrorCode,
+   message: string,
+   field?: string,
+   details?: Record<string, unknown>
+ ): AppError {
+   return {
+     code,
+     message,
+     field,
+     details
+   }
+ }
+ 
+ // Create a validation error
+ export function createValidationError(
+   field: string,
+   message: string,
+   value?: unknown
+ ): ValidationError {
+   return {
+     code: ErrorCode.VALIDATION_ERROR,
+     field,
+     message,
+     value
+   }
+ }
+ 
+ // Validation schemas for inputs
+ export const signupSchema = z.object({
+   email: z.string()
+     .email('Invalid email format')
+     .min(1, 'Email is required')
+     .max(255, 'Email must be less than 255 characters'),
+   password: z.string()
+     .min(8, 'Password must be at least 8 characters')
+     .max(128, 'Password must be less than 128 characters')
+     .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Password must contain at least one uppercase letter, one lowercase letter, and one number'),
+   name: z.string()
+     .min(2, 'Name must be at least 2 characters')
+     .max(100, 'Name must be less than 100 characters')
+     .optional()
+ })
+ 
+ export const loginSchema = z.object({
+   email: z.string()
+     .email('Invalid email format')
+     .min(1, 'Email is required'),
+   password: z.string()
+     .min(1, 'Password is required')
+ })
+ 
+ export const postCreateSchema = z.object({
+   title: z.string()
+     .min(1, 'Title is required')
+     .max(255, 'Title must be less than 255 characters')
+     .trim(),
+   content: z.string()
+     .max(10000, 'Content must be less than 10,000 characters')
+     .optional()
+ })
+ 
+ export const postUpdateSchema = z.object({
+   title: z.string()
+     .min(1, 'Title is required')
+     .max(255, 'Title must be less than 255 characters')
+     .trim()
+     .optional(),
+   content: z.string()
+     .max(10000, 'Content must be less than 10,000 characters')
+     .optional(),
+   published: z.boolean().optional()
+ })
+ 
+ // ID validation schemas
+ export const idSchema = z.object({
+   id: z.number()
+     .int('ID must be an integer')
+     .positive('ID must be positive')
+ })
+ 
+ export const userUniqueSchema = z.object({
+   id: z.number()
+     .int('ID must be an integer')
+     .positive('ID must be positive')
+     .optional(),
+   email: z.string()
+     .email('Invalid email format')
+     .optional()
+ }).refine(
+   (data) => data.id !== undefined || data.email !== undefined,
+   {
+     message: 'Either id or email must be provided',
+     path: ['id']
+   }
+ )
+ 
+ // Pagination schemas
+ export const paginationSchema = z.object({
+   skip: z.number()
+     .int('Skip must be an integer')
+     .min(0, 'Skip must be non-negative')
+     .optional(),
+   take: z.number()
+     .int('Take must be an integer')
+     .min(1, 'Take must be at least 1')
+     .max(100, 'Take must be at most 100')
+     .optional()
+ })
+ 
+ export const feedInputSchema = z.object({
+   searchString: z.string()
+     .min(1, 'Search string must not be empty')
+     .max(255, 'Search string must be less than 255 characters')
+     .optional(),
+   skip: z.number()
+     .int('Skip must be an integer')
+     .min(0, 'Skip must be non-negative')
+     .optional(),
+   take: z.number()
+     .int('Take must be an integer')
+     .min(1, 'Take must be at least 1')
+     .max(100, 'Take must be at most 100')
+     .optional(),
+   orderBy: z.object({
+     updatedAt: z.enum(['asc', 'desc']).optional(),
+     createdAt: z.enum(['asc', 'desc']).optional(),
+     viewCount: z.enum(['asc', 'desc']).optional()
+   }).optional()
+ })
+ 
+ // Generic validation function with proper error handling
+ export function validateInput<T>(
+   schema: z.ZodSchema<T>, 
+   input: unknown
+ ): Result<T, ValidationError[]> {
+   try {
+     const result = schema.parse(input)
+     return { success: true, data: result }
+   } catch (error) {
+     if (error instanceof z.ZodError) {
+       const validationErrors: ValidationError[] = error.errors.map((err) => 
+         createValidationError(
+           err.path.join('.'),
+           err.message,
+           err.code === 'invalid_type' ? input : undefined
+         )
+       )
+       return { success: false, error: validationErrors }
+     }
+     
+     return { 
+       success: false, 
+       error: [createValidationError('unknown', 'Validation failed')]
+     }
+   }
+ }
+ 
+ // Async validation wrapper
+ export async function validateInputAsync<T>(
+   schema: z.ZodSchema<T>, 
+   input: unknown
+ ): Promise<Result<T, ValidationError[]>> {
+   return Promise.resolve(validateInput(schema, input))
+ }
+ 
+ // Type guards
+ export function isValidationError(error: AppError): error is ValidationError {
+   return error.code === ErrorCode.VALIDATION_ERROR && 'field' in error
+ }
+ 
+ export function isAuthenticated(context: { userId?: number | null }): boolean {
+   return typeof context.userId === 'number' && context.userId > 0
+ }
+ 
+ // Safe parsing utilities
+ export function safeParseInt(value: unknown, defaultValue = 0): number {
+   if (typeof value === 'number') return Math.floor(value)
+   if (typeof value === 'string') {
+     const parsed = parseInt(value, 10)
+     return isNaN(parsed) ? defaultValue : parsed
+   }
+   return defaultValue
+ }
+ 
+ export function safeParseBoolean(value: unknown, defaultValue = false): boolean {
+   if (typeof value === 'boolean') return value
+   if (typeof value === 'string') {
+     return value.toLowerCase() === 'true' || value === '1'
+   }
+   if (typeof value === 'number') return value !== 0
+   return defaultValue
+ }
```

---



---

```diff
  import { z } from 'zod'
- import type { AppError, ErrorCode, Result, ValidationError } from './types'
+ import type { AppError, ValidationError, Result } from './types'
+ import { ErrorCode } from './types'
  
  // Create a custom app error
  export function createAppError(
    code: ErrorCode,
    message: string,
    field?: string,
-   details?: Record<string, unknown>,
+   details?: Record<string, unknown>
  ): AppError {
    return {
      code,
      message,
      field,
-     details,
+     details
    }
  }
  
  // Create a validation error
  export function createValidationError(
    field: string,
    message: string,
-   value?: unknown,
+   value?: unknown
  ): ValidationError {
    return {
      code: ErrorCode.VALIDATION_ERROR,
      field,
      message,
-     value,
+     value
    }
  }
  
  // Validation schemas for inputs
  export const signupSchema = z.object({
-   email: z
-     .string()
+   email: z.string()
      .email('Invalid email format')
      .min(1, 'Email is required')
      .max(255, 'Email must be less than 255 characters'),
-   password: z
-     .string()
+   password: z.string()
      .min(8, 'Password must be at least 8 characters')
      .max(128, 'Password must be less than 128 characters')
-     .regex(
-       /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
-       'Password must contain at least one uppercase letter, one lowercase letter, and one number',
-     ),
-   name: z
-     .string()
+     .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Password must contain at least one uppercase letter, one lowercase letter, and one number'),
+   name: z.string()
      .min(2, 'Name must be at least 2 characters')
      .max(100, 'Name must be less than 100 characters')
-     .optional(),
+     .optional()
  })
  
  export const loginSchema = z.object({
-   email: z.string().email('Invalid email format').min(1, 'Email is required'),
-   password: z.string().min(1, 'Password is required'),
+   email: z.string()
+     .email('Invalid email format')
+     .min(1, 'Email is required'),
+   password: z.string()
+     .min(1, 'Password is required')
  })
  
  export const postCreateSchema = z.object({
-   title: z
-     .string()
+   title: z.string()
      .min(1, 'Title is required')
      .max(255, 'Title must be less than 255 characters')
      .trim(),
-   content: z
-     .string()
+   content: z.string()
      .max(10000, 'Content must be less than 10,000 characters')
-     .optional(),
+     .optional()
  })
  
  export const postUpdateSchema = z.object({
-   title: z
-     .string()
+   title: z.string()
      .min(1, 'Title is required')
      .max(255, 'Title must be less than 255 characters')
      .trim()
      .optional(),
-   content: z
-     .string()
+   content: z.string()
      .max(10000, 'Content must be less than 10,000 characters')
      .optional(),
-   published: z.boolean().optional(),
+   published: z.boolean().optional()
  })
  
  // ID validation schemas
  export const idSchema = z.object({
-   id: z.number().int('ID must be an integer').positive('ID must be positive'),
+   id: z.number()
+     .int('ID must be an integer')
+     .positive('ID must be positive')
  })
  
- export const userUniqueSchema = z
-   .object({
-     id: z
-       .number()
-       .int('ID must be an integer')
-       .positive('ID must be positive')
-       .optional(),
-     email: z.string().email('Invalid email format').optional(),
-   })
-   .refine((data) => data.id !== undefined || data.email !== undefined, {
+ export const userUniqueSchema = z.object({
+   id: z.number()
+     .int('ID must be an integer')
+     .positive('ID must be positive')
+     .optional(),
+   email: z.string()
+     .email('Invalid email format')
+     .optional()
+ }).refine(
+   (data: { id?: number; email?: string }) => data.id !== undefined || data.email !== undefined,
+   {
      message: 'Either id or email must be provided',
-     path: ['id'],
-   })
+     path: ['id']
+   }
+ )
  
  // Pagination schemas
  export const paginationSchema = z.object({
-   skip: z
-     .number()
+   skip: z.number()
      .int('Skip must be an integer')
      .min(0, 'Skip must be non-negative')
      .optional(),
-   take: z
-     .number()
+   take: z.number()
      .int('Take must be an integer')
      .min(1, 'Take must be at least 1')
      .max(100, 'Take must be at most 100')
-     .optional(),
+     .optional()
  })
  
  export const feedInputSchema = z.object({
-   searchString: z
-     .string()
+   searchString: z.string()
      .min(1, 'Search string must not be empty')
      .max(255, 'Search string must be less than 255 characters')
      .optional(),
-   skip: z
-     .number()
+   skip: z.number()
      .int('Skip must be an integer')
      .min(0, 'Skip must be non-negative')
      .optional(),
-   take: z
-     .number()
+   take: z.number()
      .int('Take must be an integer')
      .min(1, 'Take must be at least 1')
      .max(100, 'Take must be at most 100')
      .optional(),
-   orderBy: z
-     .object({
-       updatedAt: z.enum(['asc', 'desc']).optional(),
-       createdAt: z.enum(['asc', 'desc']).optional(),
-       viewCount: z.enum(['asc', 'desc']).optional(),
-     })
-     .optional(),
+   orderBy: z.object({
+     updatedAt: z.enum(['asc', 'desc']).optional(),
+     createdAt: z.enum(['asc', 'desc']).optional(),
+     viewCount: z.enum(['asc', 'desc']).optional()
+   }).optional()
  })
  
  // Generic validation function with proper error handling
  export function validateInput<T>(
-   schema: z.ZodSchema<T>,
-   input: unknown,
+   schema: z.ZodSchema<T>, 
+   input: unknown
  ): Result<T, ValidationError[]> {
    try {
      const result = schema.parse(input)
      return { success: true, data: result }
-   } catch (error) {
+   } catch (error: unknown) {
      if (error instanceof z.ZodError) {
-       const validationErrors: ValidationError[] = error.errors.map((err) =>
+       const validationErrors: ValidationError[] = error.errors.map((err: z.ZodIssue) => 
          createValidationError(
            err.path.join('.'),
            err.message,
-           err.code === 'invalid_type' ? input : undefined,
-         ),
+           err.code === 'invalid_type' ? input : undefined
+         )
        )
        return { success: false, error: validationErrors }
      }
- 
-     return {
-       success: false,
-       error: [createValidationError('unknown', 'Validation failed')],
+     
+     return { 
+       success: false, 
+       error: [createValidationError('unknown', 'Validation failed')]
      }
    }
  }
  
  // Async validation wrapper
  export async function validateInputAsync<T>(
-   schema: z.ZodSchema<T>,
-   input: unknown,
+   schema: z.ZodSchema<T>, 
+   input: unknown
  ): Promise<Result<T, ValidationError[]>> {
    return Promise.resolve(validateInput(schema, input))
  }
```

```diff
    return defaultValue
  }
  
- export function safeParseBoolean(
-   value: unknown,
-   defaultValue = false,
- ): boolean {
+ export function safeParseBoolean(value: unknown, defaultValue = false): boolean {
    if (typeof value === 'boolean') return value
    if (typeof value === 'string') {
      return value.toLowerCase() === 'true' || value === '1'
```

---



---

```diff
    orderBy?: PostOrderByInput
  }
  
- // Error Types
- export enum ErrorCode {
+ // Error Types - Export as const enum so it can be used as both type and value
+ export const enum ErrorCode {
    AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
    AUTHORIZATION_ERROR = 'AUTHORIZATION_ERROR',
    VALIDATION_ERROR = 'VALIDATION_ERROR',
    NOT_FOUND = 'NOT_FOUND',
    INTERNAL_ERROR = 'INTERNAL_ERROR',
    DUPLICATE_ERROR = 'DUPLICATE_ERROR',
-   NETWORK_ERROR = 'NETWORK_ERROR',
+   NETWORK_ERROR = 'NETWORK_ERROR'
  }
  
  export interface AppError {
```

```diff
  }
  
  // Result Types for better error handling
- export type Result<T, E = AppError> =
+ export type Result<T, E = AppError> = 
    | { success: true; data: T }
    | { success: false; error: E }
  
```

```diff
  // Utility Types
  export type NonNullable<T> = T extends null | undefined ? never : T
  
- export type OptionalFields<T, K extends keyof T> = Omit<T, K> &
-   Partial<Pick<T, K>>
+ export type OptionalFields<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>
  
  export type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>
  
```

---



---

```diff
- import { verify } from 'jsonwebtoken'
+ import { verify, sign, type JwtPayload } from 'jsonwebtoken'
+ import { hash, compare } from 'bcryptjs'
  import type { Context } from './context'
+ import type { JWTPayload, User, Result, AppError } from './types'
+ import { ErrorCode, createAppError } from './validation'
+ import { env } from './environment'
  
- export const APP_SECRET = 'appsecret321'
+ // Security constants
+ export const SALT_ROUNDS = 12
+ export const TOKEN_EXPIRY = '7d'
+ export const REFRESH_TOKEN_EXPIRY = '30d'
  
- interface Token {
-     userId: string
+ // JWT token management with proper error handling
+ export async function generateTokens(userId: number, email: string): Promise<{
+   accessToken: string
+   refreshToken: string
+ }> {
+   const payload: Omit<JWTPayload, 'iat' | 'exp'> = {
+     userId: userId.toString(),
+     email
+   }
+ 
+   const accessToken = sign(payload, env.APP_SECRET, { 
+     expiresIn: TOKEN_EXPIRY,
+     issuer: 'graphql-auth',
+     audience: 'graphql-api'
+   })
+ 
+   const refreshToken = sign(payload, env.APP_SECRET, { 
+     expiresIn: REFRESH_TOKEN_EXPIRY,
+     issuer: 'graphql-auth',
+     audience: 'graphql-refresh'
+   })
+ 
+   return { accessToken, refreshToken }
  }
  
  export function getUserId(context: Context): number | null {
-     console.log(context.req)
-     if (context.req.headers) {
-         const authHeader = context.req.headers['authorization'] as string | undefined
-         if (authHeader && typeof authHeader === 'string') {
-             const token = authHeader.replace('Bearer ', '')
-             const verifiedToken = verify(token, APP_SECRET) as Token
-             return verifiedToken && Number(verifiedToken.userId)
-         }
+   try {
+     if (!context.req.headers.authorization) {
+       return null
      }
  
+     const authHeader = context.req.headers.authorization
+     if (typeof authHeader !== 'string' || !authHeader.startsWith('Bearer ')) {
+       return null
+     }
+ 
+     const token = authHeader.replace('Bearer ', '').trim()
+     if (!token) {
+       return null
+     }
+ 
+     const verifiedToken = verify(token, env.APP_SECRET, {
+       issuer: 'graphql-auth',
+       audience: 'graphql-api'
+     }) as JwtPayload & JWTPayload
+ 
+     if (!verifiedToken || !verifiedToken.userId) {
+       return null
+     }
+ 
+     const userId = parseInt(verifiedToken.userId, 10)
+     return isNaN(userId) ? null : userId
+ 
+   } catch (error) {
+     // Log the error for debugging but don't expose it
+     console.error('Token verification failed:', error instanceof Error ? error.message : 'Unknown error')
      return null
+   }
+ }
+ 
+ // Enhanced user authentication with proper error handling
+ export async function authenticateUser(
+   email: string, 
+   password: string,
+   getUserByEmail: (email: string) => Promise<User & { password: string } | null>
+ ): Promise<Result<{ user: User; tokens: { accessToken: string; refreshToken: string } }, AppError>> {
+   try {
+     // Validate input
+     if (!email || !password) {
+       return {
+         success: false,
+         error: createAppError(ErrorCode.VALIDATION_ERROR, 'Email and password are required')
+       }
+     }
+ 
+     // Get user from database
+     const userWithPassword = await getUserByEmail(email.toLowerCase().trim())
+     if (!userWithPassword) {
+       return {
+         success: false,
+         error: createAppError(ErrorCode.AUTHENTICATION_ERROR, 'Invalid credentials')
+       }
+     }
+ 
+     // Verify password
+     const isValidPassword = await compare(password, userWithPassword.password)
+     if (!isValidPassword) {
+       return {
+         success: false,
+         error: createAppError(ErrorCode.AUTHENTICATION_ERROR, 'Invalid credentials')
+       }
+     }
+ 
+     // Remove password from user object
+     const { password: _, ...user } = userWithPassword
+ 
+     // Generate tokens
+     const tokens = await generateTokens(user.id, user.email)
+ 
+     return {
+       success: true,
+       data: { user, tokens }
+     }
+ 
+   } catch (error) {
+     console.error('Authentication error:', error)
+     return {
+       success: false,
+       error: createAppError(ErrorCode.INTERNAL_ERROR, 'Authentication failed')
+     }
+   }
+ }
+ 
+ // Enhanced password hashing with proper error handling
+ export async function hashPassword(password: string): Promise<Result<string, AppError>> {
+   try {
+     if (!password || password.length < 8) {
+       return {
+         success: false,
+         error: createAppError(ErrorCode.VALIDATION_ERROR, 'Password must be at least 8 characters')
+       }
+     }
+ 
+     const hashedPassword = await hash(password, SALT_ROUNDS)
+     return { success: true, data: hashedPassword }
+ 
+   } catch (error) {
+     console.error('Password hashing error:', error)
+     return {
+       success: false,
+       error: createAppError(ErrorCode.INTERNAL_ERROR, 'Password hashing failed')
+     }
+   }
+ }
+ 
+ // Enhanced authorization helpers
+ export function requireAuth(context: Context): Result<number, AppError> {
+   const userId = getUserId(context)
+   
+   if (!userId) {
+     return {
+       success: false,
+       error: createAppError(ErrorCode.AUTHENTICATION_ERROR, 'Authentication required')
+     }
+   }
+ 
+   return { success: true, data: userId }
+ }
+ 
+ export function requireOwnership(
+   context: Context, 
+   resourceUserId: number | null | undefined
+ ): Result<number, AppError> {
+   const authResult = requireAuth(context)
+   if (!authResult.success) {
+     return authResult
+   }
+ 
+   if (!resourceUserId || authResult.data !== resourceUserId) {
+     return {
+       success: false,
+       error: createAppError(ErrorCode.AUTHORIZATION_ERROR, 'Access denied')
+     }
+   }
+ 
+   return authResult
+ }
+ 
+ // Utility functions for data validation and sanitization
+ export function sanitizeEmail(email: string): string {
+   return email.toLowerCase().trim()
+ }
+ 
+ export function sanitizeString(input: string, maxLength = 1000): string {
+   return input.trim().substring(0, maxLength)
+ }
+ 
+ export function isValidEmail(email: string): boolean {
+   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
+   return emailRegex.test(email)
+ }
+ 
+ // Request metadata helpers
+ export function extractRequestMetadata(context: Context): {
+   ip?: string
+   userAgent?: string
+   contentType?: string
+ } {
+   const headers = context.req.headers
+   
+   return {
+     ip: headers['x-forwarded-for'] || headers['x-real-ip'] || 'unknown',
+     userAgent: headers['user-agent'] || 'unknown',
+     contentType: headers['content-type'] || 'unknown'
+   }
+ }
+ 
+ // Error formatting for GraphQL
+ export function formatGraphQLError(error: AppError): {
+   message: string
+   code: string
+   field?: string
+   timestamp: string
+ } {
+   return {
+     message: error.message,
+     code: error.code,
+     field: error.field,
+     timestamp: new Date().toISOString()
+   }
+ }
+ 
+ // Rate limiting helpers (placeholder for future implementation)
+ export function createRateLimitKey(context: Context, operation: string): string {
+   const userId = getUserId(context)
+   const metadata = extractRequestMetadata(context)
+   
+   return userId 
+     ? `user:${userId}:${operation}`
+     : `ip:${metadata.ip}:${operation}`
+ }
+ 
+ // Logging helpers
+ export function createLogContext(context: Context, operation?: string): {
+   userId?: number
+   operation?: string
+   ip?: string
+   userAgent?: string
+   timestamp: string
+ } {
+   const userId = getUserId(context)
+   const metadata = extractRequestMetadata(context)
+   
+   return {
+     userId: userId || undefined,
+     operation,
+     ip: metadata.ip,
+     userAgent: metadata.userAgent,
+     timestamp: new Date().toISOString()
+   }
  }   
```

---



---

```diff
  import type { Context } from './context'
  import { env } from './environment'
  import type { AppError, JWTPayload, Result, User } from './types'
- import { ErrorCode, createAppError } from './validation'
+ import { ErrorCode } from './types'
+ import { createAppError } from './validation'
  
  // Security constants
  export const SALT_ROUNDS = 12
```

---



---

```diff
  import type {
    Endpoint,
    HTTPMethod,
-   TypedFetchResponseBody
+   TypedFetchResponseBody,
+   MimeType
  } from 'fetchdts'
  import { graphql, type ResultOf, type VariablesOf } from 'gql.tada'
  import { IncomingMessage } from 'http'
+ import type { 
+   User, 
+   Post, 
+   AuthPayload, 
+   JWTPayload, 
+   SecurityContext, 
+   RequestMetadata,
+   SignupInput,
+   LoginInput,
+   PostCreateInput,
+   UserUniqueInput,
+   FeedInput
+ } from './types'
+ import { getUserId, extractRequestMetadata } from './utils'
  
- // Define types for GraphQL operations
- interface User {
-   id: number
-   email: string
-   name?: string
-   posts: Post[]
- }
- 
- interface Post {
-   id: number
-   title: string
-   content?: string
-   published: boolean
-   author: User
-   createdAt: string
-   updatedAt: string
-   viewCount: number
- }
- 
+ // Enhanced GraphQL operations with proper type safety
  export const LoginMutation = graphql(`
    mutation Login($email: String!, $password: String!) {
      login(email: $email, password: $password) {
```

```diff
    }
  `)
  
+ export const GetMeQuery = graphql(`
+   query GetMe {
+     me {
+       id
+       email
+       name
+       posts {
+         id
+         title
+         published
+         createdAt
+       }
+     }
+   }
+ `)
+ 
+ export const GetPostsQuery = graphql(`
+   query GetPosts($input: FeedInput) {
+     feed(input: $input) {
+       id
+       title
+       content
+       published
+       viewCount
+       createdAt
+       author {
+         id
+         name
+       }
+     }
+   }
+ `)
+ 
  // Type aliases for easy access to query types
  export type LoginResult = ResultOf<typeof LoginMutation>
  export type LoginVariables = VariablesOf<typeof LoginMutation>
  export type SignupResult = ResultOf<typeof SignupMutation>
  export type SignupVariables = VariablesOf<typeof SignupMutation>
  export type CreateDraftResult = ResultOf<typeof CreateDraftMutation>
  export type CreateDraftVariables = VariablesOf<typeof CreateDraftMutation>
+ export type GetMeResult = ResultOf<typeof GetMeQuery>
+ export type GetPostsResult = ResultOf<typeof GetPostsQuery>
+ export type GetPostsVariables = VariablesOf<typeof GetPostsQuery>
  
- // GraphQL request body type
+ // GraphQL request body type with proper validation
  interface GraphQLRequestBody {
    query: string
    variables?: Record<string, unknown>
    operationName?: string
  }
  
- // GraphQL response type
+ // Enhanced GraphQL response type
  export interface GraphQLResponse<T = unknown> {
    data?: T
    errors?: Array<{
      message: string
      locations?: Array<{ line: number; column: number }>
      path?: Array<string | number>
+     extensions?: {
+       code?: string
+       field?: string
+       timestamp?: string
+     }
    }>
  }
  
```

```diff
          headers: {
            'content-type': 'application/json'
            authorization?: string
+           'user-agent'?: string
+           'x-forwarded-for'?: string
+           'x-real-ip'?: string
          }
          response: GraphQLResponse
          responseHeaders: {
            'content-type': 'application/json'
+           'cache-control'?: string
          }
        }
      }
    }
+   '/health': {
+     [Endpoint]: {
+       GET: {
+         response: {
+           status: 'ok' | 'error'
+           timestamp: string
+           uptime: number
+         }
+         responseHeaders: {
+           'content-type': 'application/json'
+         }
+       }
+     }
+   }
  }
  
- // Enhanced context interface with proper typing
+ // Enhanced context interface with comprehensive typing
  export interface Context {
    req: {
      url: string
```

```diff
    }
    headers: Record<string, string>
    method: HTTPMethod
-   contentType: string
+   contentType: MimeType | string
+   metadata: RequestMetadata
+   security: SecurityContext
+   userId?: number
+   user?: User
  }
  
- // Update the context function to handle Apollo Server's context with better typing
+ // Create enhanced context with proper error handling and type safety
  export const createContext: ContextFunction<[{ req: IncomingMessage }], Context> = async ({ req }) => {
-   // Convert IncomingMessage headers to record
+   // Convert IncomingMessage headers to record with proper typing
    const headers: Record<string, string> = {}
    Object.entries(req.headers).forEach(([key, value]) => {
      if (value) {
        headers[key] = Array.isArray(value) ? value.join(', ') : String(value)
      }
    })
  
-   // Create context with proper typing
-   const context: Context = {
+   // Extract method and URL with defaults
+   const method = (req.method as HTTPMethod) || 'POST'
+   const url = req.url || '/graphql'
+   const contentType = headers['content-type'] || 'application/json'
+ 
+   // Create request metadata
+   const metadata: RequestMetadata = {
+     ip: headers['x-forwarded-for'] || headers['x-real-ip'] || 'unknown',
+     userAgent: headers['user-agent'] || 'unknown',
+     operationName: undefined, // Will be set later from GraphQL request
+     query: undefined, // Will be set later from GraphQL request
+     variables: undefined, // Will be set later from GraphQL request
+     startTime: Date.now()
+   }
+ 
+   // Create basic context structure
+   const basicContext = {
      req: {
-       url: req.url || '/graphql',
-       method: (req.method as HTTPMethod) || 'POST',
+       url,
+       method,
        headers,
-       body: (req as any).body
+       body: (req as any).body as GraphQLRequestBody | undefined
      },
      headers,
-     method: (req.method as HTTPMethod) || 'POST',
-     contentType: headers['content-type'] || 'application/json'
+     method,
+     contentType,
+     metadata
    }
  
+   // Get user ID and create security context
+   const userId = getUserId(basicContext as Context)
+   const isAuthenticated = Boolean(userId)
+ 
+   const security: SecurityContext = {
+     isAuthenticated,
+     userId: userId || undefined,
+     userEmail: undefined, // Will be populated if needed
+     roles: [], // Will be populated based on user data
+     permissions: [] // Will be populated based on user roles
+   }
+ 
+   // Create final enhanced context
+   const context: Context = {
+     ...basicContext,
+     security,
+     userId: userId || undefined,
+     user: undefined // Will be populated by resolvers if needed
+   }
+ 
    return context
  }
  
- // Type-safe GraphQL execution with fetchdts integration
+ // Type-safe GraphQL execution with enhanced error handling
  export async function executeGraphQL<TData = unknown, TVariables = Record<string, unknown>>(
    query: string,
    variables?: TVariables,
    headers?: Record<string, string>
  ): Promise<GraphQLResponse<TData>> {
-   const requestBody = JSON.stringify({
-     query,
-     variables,
-   })
+   try {
+     const requestBody: GraphQLRequestBody = {
+       query,
+       variables: variables as Record<string, unknown>,
+     }
  
-   const response = await fetch('/graphql', {
-     method: 'POST',
-     headers: {
-       'Content-Type': 'application/json',
-       ...headers,
-     },
-     body: requestBody,
-   })
+     const response = await fetch('/graphql', {
+       method: 'POST',
+       headers: {
+         'Content-Type': 'application/json',
+         ...headers,
+       },
+       body: JSON.stringify(requestBody),
+     })
  
-   return response.json() as Promise<GraphQLResponse<TData>>
+     if (!response.ok) {
+       throw new Error(`HTTP error! status: ${response.status}`)
+     }
+ 
+     const result = await response.json() as GraphQLResponse<TData>
+     return result
+ 
+   } catch (error) {
+     // Return a properly formatted GraphQL error response
+     return {
+       errors: [{
+         message: error instanceof Error ? error.message : 'Unknown error occurred',
+         extensions: {
+           code: 'NETWORK_ERROR',
+           timestamp: new Date().toISOString()
+         }
+       }]
+     }
+   }
  }
  
  // Helper type for GraphQL endpoint response
```

```diff
      body: body ? JSON.stringify(body) : undefined,
    }
  }
+ 
+ // Enhanced context helpers
+ export function isAuthenticated(context: Context): boolean {
+   return context.security.isAuthenticated
+ }
+ 
+ export function requireAuthentication(context: Context): number {
+   if (!context.security.isAuthenticated || !context.userId) {
+     throw new Error('Authentication required')
+   }
+   return context.userId
+ }
+ 
+ export function hasPermission(context: Context, permission: string): boolean {
+   return context.security.permissions?.includes(permission) || false
+ }
+ 
+ export function hasRole(context: Context, role: string): boolean {
+   return context.security.roles?.includes(role) || false
+ }
+ 
+ // Context validation helpers
+ export function validateContext(context: Context): {
+   isValid: boolean
+   errors: string[]
+ } {
+   const errors: string[] = []
+ 
+   if (!context.method) {
+     errors.push('HTTP method is required')
+   }
+ 
+   if (!context.contentType) {
+     errors.push('Content-Type header is required')
+   }
+ 
+   if (context.method === 'POST' && !context.req.body) {
+     errors.push('Request body is required for POST requests')
+   }
+ 
+   return {
+     isValid: errors.length === 0,
+     errors
+   }
+ }
  
```

---



---

Read file: package.json

---



---

```diff
  import { ContextFunction } from '@apollo/server'
- import type {
-   Endpoint,
-   HTTPMethod,
-   MimeType,
-   TypedFetchResponseBody,
- } from 'fetchdts'
  import { graphql, type ResultOf, type VariablesOf } from 'gql.tada'
  import { IncomingMessage } from 'http'
- import type { RequestMetadata, SecurityContext, User } from './types'
- import { getUserId } from './utils'
+ import type { 
+   User, 
+   Post, 
+   AuthPayload, 
+   JWTPayload, 
+   SecurityContext, 
+   RequestMetadata,
+   SignupInput,
+   LoginInput,
+   PostCreateInput,
+   UserUniqueInput,
+   FeedInput
+ } from './types'
+ import { getUserId, extractRequestMetadata } from './utils'
  
+ // HTTP method types
+ export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS'
+ export type MimeType = 'application/json' | 'application/xml' | 'text/plain' | 'text/html' | string
+ 
  // Enhanced GraphQL operations with proper type safety
  export const LoginMutation = graphql(`
    mutation Login($email: String!, $password: String!) {
```

```diff
    }>
  }
  
- // Enhanced API Schema for fetchdts with proper endpoint typing
- export interface GraphQLAPISchema {
-   '/graphql': {
-     [Endpoint]: {
-       POST: {
-         body: GraphQLRequestBody
-         headers: {
-           'content-type': 'application/json'
-           authorization?: string
-           'user-agent'?: string
-           'x-forwarded-for'?: string
-           'x-real-ip'?: string
-         }
-         response: GraphQLResponse
-         responseHeaders: {
-           'content-type': 'application/json'
-           'cache-control'?: string
-         }
-       }
-     }
-   }
-   '/health': {
-     [Endpoint]: {
-       GET: {
-         response: {
-           status: 'ok' | 'error'
-           timestamp: string
-           uptime: number
-         }
-         responseHeaders: {
-           'content-type': 'application/json'
-         }
-       }
-     }
-   }
- }
- 
  // Enhanced context interface with comprehensive typing
  export interface Context {
    req: {
```

```diff
  }
  
  // Create enhanced context with proper error handling and type safety
- export const createContext: ContextFunction<
-   [{ req: IncomingMessage }],
-   Context
- > = async ({ req }) => {
+ export const createContext: ContextFunction<[{ req: IncomingMessage }], Context> = async ({ req }) => {
    // Convert IncomingMessage headers to record with proper typing
    const headers: Record<string, string> = {}
    Object.entries(req.headers).forEach(([key, value]) => {
```

```diff
      operationName: undefined, // Will be set later from GraphQL request
      query: undefined, // Will be set later from GraphQL request
      variables: undefined, // Will be set later from GraphQL request
-     startTime: Date.now(),
+     startTime: Date.now()
    }
  
    // Create basic context structure
```

```diff
        url,
        method,
        headers,
-       body: (req as any).body as GraphQLRequestBody | undefined,
+       body: (req as any).body as GraphQLRequestBody | undefined
      },
      headers,
      method,
      contentType,
-     metadata,
+     metadata
    }
  
    // Get user ID and create security context
```

```diff
      userId: userId || undefined,
      userEmail: undefined, // Will be populated if needed
      roles: [], // Will be populated based on user data
-     permissions: [], // Will be populated based on user roles
+     permissions: [] // Will be populated based on user roles
    }
  
    // Create final enhanced context
    const context: Context = {
      ...basicContext,
      security,
      userId: userId || undefined,
-     user: undefined, // Will be populated by resolvers if needed
+     user: undefined // Will be populated by resolvers if needed
    }
  
    return context
  }
  
  // Type-safe GraphQL execution with enhanced error handling
- export async function executeGraphQL<
-   TData = unknown,
-   TVariables = Record<string, unknown>,
- >(
+ export async function executeGraphQL<TData = unknown, TVariables = Record<string, unknown>>(
    query: string,
    variables?: TVariables,
-   headers?: Record<string, string>,
+   headers?: Record<string, string>
  ): Promise<GraphQLResponse<TData>> {
    try {
      const requestBody: GraphQLRequestBody = {
```

```diff
        throw new Error(`HTTP error! status: ${response.status}`)
      }
  
-     const result = (await response.json()) as GraphQLResponse<TData>
+     const result = await response.json() as GraphQLResponse<TData>
      return result
+ 
    } catch (error) {
      // Return a properly formatted GraphQL error response
      return {
-       errors: [
-         {
-           message:
-             error instanceof Error ? error.message : 'Unknown error occurred',
-           extensions: {
-             code: 'NETWORK_ERROR',
-             timestamp: new Date().toISOString(),
-           },
-         },
-       ],
+       errors: [{
+         message: error instanceof Error ? error.message : 'Unknown error occurred',
+         extensions: {
+           code: 'NETWORK_ERROR',
+           timestamp: new Date().toISOString()
+         }
+       }]
      }
    }
  }
  
- // Helper type for GraphQL endpoint response
- export type GraphQLEndpointResponse<T> = TypedFetchResponseBody<
-   GraphQLAPISchema,
-   '/graphql',
-   'POST'
- > & {
-   data?: T
- }
- 
- // Type-safe request helper using fetchdts types
- export function createTypedRequest<T extends keyof GraphQLAPISchema>(
-   endpoint: T,
+ // Type-safe request helper
+ export function createTypedRequest(
    method: HTTPMethod,
    body?: GraphQLRequestBody,
-   headers?: Record<string, string>,
+   headers?: Record<string, string>
  ): RequestInit {
    return {
      method,
```

```diff
  
    return {
      isValid: errors.length === 0,
-     errors,
+     errors
    }
  }
  
```

---



---



---

