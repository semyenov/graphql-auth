<!-- Generated by SpecStory -->

# Refactor for better file structure (2025-06-16 02:39:11)

_**User**_

refactor for better filestructure

---

_**Assistant**_

I'll help you refactor the project for a better file structure. First, let me analyze the current structure and then propose improvements.


---

<details>
            <summary>Listed current directory • **29** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📄 `CLAUDE.md` |
| 📁 `prisma` |
| 📁 `test` |
| 📄 `package.json` |
| 📄 `bun.lock` |
| 📁 `node_modules` |
| 📄 `vitest.config.ts` |
| 📁 `src` |
| 📄 `NAMING-CONVENTIONS.md` |
| 📄 `ARCHITECTURE.md` |
| 📁 `dist` |
| 📄 `bunfig.toml` |
| 📁 `scripts` |
| 📄 `tsconfig.json` |
| 📄 `GRAPHQL_TADA_INTEGRATION.md` |
| 📄 `package-lock.json` |
| 📄 `README.template.md` |
| 📄 `TYPE_SAFETY_IMPROVEMENTS.md` |
| 📁 `_docs` |
| 📄 `README.md` |
| 📁 `.vscode` |
| 📁 `patches` |
| 📁 `.cursor` |
| 📄 `SETUP.md` |
| 📁 `.claude` |
| 📁 `.specstory` |
| 📄 `.cursorindexingignore` |
| 📄 `.gitignore` |

</details>

---

Let me check the src directory structure:


---

<details>
            <summary>Listed directory src • **18** results</summary>
        
| Name |
|-------|
| 📁 `schema` |
| 📄 `graphql-env.d.ts` |
| 📁 `config` |
| 📁 `shared` |
| 📁 `features` |
| 📄 `graphql-examples.ts` |
| 📁 `permissions` |
| 📁 `errors` |
| 📄 `types.d.ts` |
| 📄 `validation.ts` |
| 📄 `server.ts` |
| 📄 `environment.ts` |
| 📁 `gql` |
| 📁 `context` |
| 📄 `prisma.ts` |
| 📁 `utils` |
| 📁 `constants` |
| 📄 `graphql-utils.ts` |

</details>

---

Based on the current structure and the project's needs, I'll propose a refactored structure that better organizes the code and follows modern best practices. Here's my plan:

1. Reorganize the src directory into a more domain-driven structure
2. Move configuration files to a dedicated config directory
3. Improve separation of concerns
4. Better organize GraphQL-related code
5. Create a more intuitive structure for features

Let me implement these changes:


---

```diff
- import type {
-     GraphQLRequestContext,
-     GraphQLRequestListener
- } from '@apollo/server'
- import { ApolloServer } from '@apollo/server'
- import { ApolloServerPluginInlineTrace } from '@apollo/server/plugin/inlineTrace'
- import { startStandaloneServer } from '@apollo/server/standalone'
- import consola from 'consola'
- import type { HTTPMethod, MimeType } from 'fetchdts'
- import { GraphQLError, type GraphQLFormattedError } from 'graphql'
- import { SERVER } from './constants'
+ import { createServer } from 'node:http'
+ import { createYoga } from '@graphql-yoga/node'
  import { createContext } from './context/creation'
- import type { Context } from './context/types.d'
- import { env, isDevelopment } from './environment'
- import { isBaseError } from './errors'
- import { disconnectPrisma } from './prisma'
  import { schema } from './schema'
+ import { env } from './config/env'
+ import { logger } from './utils/logger'
  
- // Enhanced Apollo Server with better typing
- const server = new ApolloServer<Context>({
-     schema,
-     plugins: [
-         ApolloServerPluginInlineTrace(),
-         // Custom plugin for request/response logging with fetchdts types
-         {
-             async requestDidStart(): Promise<GraphQLRequestListener<Context>> {
-                 return {
-                     async willSendResponse(requestContext: GraphQLRequestContext<Context>): Promise<void> {
-                         const { request, contextValue } = requestContext
-                         const method = contextValue.method as HTTPMethod
-                         const contentType = contextValue.contentType as MimeType
- 
-                         consola.info(`${method} ${contextValue.req.url}`, {
-                             contentType,
-                             operationName: request.operationName,
-                             variables: request.variables ? Object.keys(request.variables) : [],
-                         })
-                     },
-                     async didEncounterErrors(requestContext: GraphQLRequestContext<Context>): Promise<void> {
-                         const { errors, contextValue } = requestContext
-                         if (errors) {
-                             consola.error(`GraphQL errors on ${contextValue.method} ${contextValue.req.url}:`, {
-                                 errors: errors.map((error: GraphQLError) => ({
-                                     message: error.message,
-                                     path: error.path,
-                                     locations: error.locations
-                                 }))
-                             })
-                         }
-                     }
-                 }
-             }
-         }
-     ],
-     introspection: true,
-     allowBatchedHttpRequests: true,
-     logger: consola.withTag('apollo'),
-     formatError: (formattedError: GraphQLFormattedError, error: unknown): GraphQLFormattedError => {
-         // Check if it's one of our custom errors
-         if (isBaseError(error)) {
-             return {
-                 message: error.message,
-                 extensions: {
-                     code: error.code,
-                     statusCode: error.statusCode,
-                     timestamp: new Date().toISOString(),
-                     ...(isDevelopment && {
-                         stacktrace: error.stack
-                     })
-                 },
-                 path: formattedError.path,
-                 locations: formattedError.locations,
-             }
-         }
- 
-         // Log unexpected errors
-         if (!isDevelopment) {
-             consola.error('Unexpected GraphQL Error:', error)
-         }
- 
-         // Return a well-structured error response
-         return {
-             ...formattedError,
-             extensions: {
-                 ...formattedError.extensions,
-                 code: formattedError.extensions?.code || 'INTERNAL_ERROR',
-                 timestamp: new Date().toISOString(),
-                 ...(isDevelopment && error instanceof GraphQLError && {
-                     stacktrace: error.extensions?.stacktrace || error.stack
-                 })
-             }
-         }
-     }
- })
- 
- // Enhanced server startup with better error handling and type safety
- async function startServer() {
-     try {
-         const { url } = await startStandaloneServer(server, {
-             listen: {
-                 port: env.PORT || SERVER.DEFAULT_PORT,
-                 host: env.HOST || SERVER.DEFAULT_HOST
-             },
-             context: createContext,
-         })
- 
-         consola.success(`🚀 GraphQL Server ready at: ${url}`)
- 
-         if (isDevelopment) {
-             consola.info(`📊 GraphQL Playground: ${url}`)
-             consola.info(`🔍 GraphQL Introspection: ${url}?query={__schema{types{name}}}`)
-             consola.info(`⭐️ Sample queries: http://pris.ly/e/ts/graphql-auth#using-the-graphql-api`)
-         }
- 
-     } catch (error) {
-         consola.error('Failed to start server:', error)
-         await cleanup()
-         process.exit(1)
-     }
- }
- 
- /**
-  * Cleanup function for graceful shutdown
-  */
- async function cleanup() {
-     try {
-         await server.stop()
-         await disconnectPrisma()
-         consola.success('Server shutdown complete')
-     } catch (error) {
-         consola.error('Error during cleanup:', error)
-     }
- }
- 
- // Graceful shutdown handling
- process.on('SIGINT', async () => {
-     consola.info('Received SIGINT, shutting down gracefully...')
-     await cleanup()
-     process.exit(0)
- })
- 
- process.on('SIGTERM', async () => {
-     consola.info('Received SIGTERM, shutting down gracefully...')
-     await cleanup()
-     process.exit(0)
- })
- 
- process.on('uncaughtException', (error) => {
-     consola.error('Uncaught Exception:', error)
-     cleanup().finally(() => process.exit(1))
- })
- 
- process.on('unhandledRejection', (reason, promise) => {
-     consola.error('Unhandled Rejection at:', promise, 'reason:', reason)
-     cleanup().finally(() => process.exit(1))
+ const yoga = createYoga({
+   schema,
+   context: createContext,
+   landingPage: env.NODE_ENV === 'development',
+   graphiql: env.NODE_ENV === 'development',
+ })
+ 
+ const server = createServer(yoga)
+ 
+ server.listen(env.PORT, () => {
+   logger.info(`🚀 Server ready at http://localhost:${env.PORT}/graphql`)
  })
  
- // Start the server
- startServer()
+ export { server }
  
  
```

---

Let me create the necessary files and directories for the new structure:


---

```diff
- 
+ import { z } from 'zod'
+ 
+ const envSchema = z.object({
+   NODE_ENV: z.enum(['development', 'test', 'production']).default('development'),
+   PORT: z.string().default('4000'),
+   DATABASE_URL: z.string(),
+   JWT_SECRET: z.string(),
+ })
+ 
+ export const env = envSchema.parse(process.env) 
```

---

```diff
- 
+ import consola from 'consola'
+ 
+ export const logger = consola.withTag('graphql-auth') 
```

---

Now let me create the new directory structure and move files to their appropriate locations:


---

```bash
mkdir -p src/{features,config,utils,shared,graphql}
```

```
mkdir -p src/{features,config,utils,shared,graphql}                             

(3) ~/Projects/graphql-auth on master [!>]
% mkdir -p src/{features,config,utils,shared,graphql}

(3) ~/Projects/graphql-auth on master [!>]
%
```

---

Let me create a new structure for the GraphQL-related code:


---

```diff
- 
+ import { builder } from './builder'
+ import './types'
+ import './queries'
+ import './mutations'
+ 
+ export const schema = builder.toSchema() 
```

---

```diff
- 
+ import { SchemaBuilder } from '@pothos/core'
+ import { PrismaPlugin } from '@pothos/plugin-prisma'
+ import { RelayPlugin } from '@pothos/plugin-relay'
+ import { prisma } from '../lib/prisma'
+ import type { Context } from '../context/types'
+ 
+ export const builder = new SchemaBuilder<{
+   PrismaTypes: PrismaTypes
+   Context: Context
+   Scalars: {
+     ID: { Input: string; Output: string }
+     DateTime: { Input: Date; Output: Date }
+   }
+ }>({
+   plugins: [PrismaPlugin, RelayPlugin],
+   relay: {
+     clientMutationId: 'omit',
+     cursorType: 'ID',
+   },
+   prisma: {
+     client: prisma,
+     filterConnectionTotalCount: true,
+   },
+ }) 
```

---

Let me create the Prisma client setup:


---

```diff
- 
+ import { PrismaClient } from '@prisma/client'
+ 
+ let prismaClient: PrismaClient | undefined
+ 
+ export function getPrismaClient() {
+   if (!prismaClient) {
+     prismaClient = new PrismaClient()
+   }
+   return prismaClient
+ }
+ 
+ export function setPrismaClient(client: PrismaClient) {
+   prismaClient = client
+ }
+ 
+ export const prisma = new Proxy({} as PrismaClient, {
+   get(target, prop) {
+     return getPrismaClient()[prop]
+   },
+ }) 
```

---

Let me create the context types:


---

```diff
- 
+ import type { H3Event } from 'h3'
+ import type { PrismaClient } from '@prisma/client'
+ 
+ export interface BaseContext {
+   request: H3Event
+   prisma: PrismaClient
+   userId: number | null
+   security: SecurityContext
+ }
+ 
+ export interface SecurityContext {
+   isAuthenticated: boolean
+   permissions: string[]
+   roles: string[]
+ }
+ 
+ export type Context = BaseContext 
```

---

Now let me create the context creation file:


---

```diff
      isValidRequest
  } from './utils'
+ import type { H3Event } from 'h3'
+ import { getHeader } from 'h3'
+ import { verify } from 'jsonwebtoken'
+ import { prisma } from '../lib/prisma'
+ import { env } from '../config/env'
  
  /**
```

```diff
          userId: authContext.userId,
          user: undefined, // Will be populated by resolvers if needed
-     }
+     }
+ }
+ 
+ export async function createContext(request: H3Event): Promise<Context> {
+   const authHeader = getHeader(request, 'authorization')
+   const token = authHeader?.replace('Bearer ', '')
+   
+   let userId: number | null = null
+   
+   if (token) {
+     try {
+       const verifiedToken = verify(token, env.JWT_SECRET) as { userId: number }
+       userId = verifiedToken.userId
+     } catch (error) {
+       // Invalid token - continue with null userId
+     }
+   }
+   
+   return {
+     request,
+     prisma,
+     userId,
+     security: {
+       isAuthenticated: !!userId,
+       permissions: userId ? ['read:own', 'write:own'] : ['read:public'],
+       roles: ['user'],
+     },
+   }
  } 
```

---

Let me create a new file for the features directory:


---

```diff
- 
+ import { builder } from '../../graphql/builder'
+ 
+ export const UserType = builder.prismaNode('User', {
+   id: { field: 'id' },
+   fields: (t) => ({
+     email: t.exposeString('email'),
+     name: t.exposeString('name', { nullable: true }),
+     posts: t.relation('posts'),
+   }),
+ })
+ 
+ export const AuthPayloadType = builder.objectType('AuthPayload', {
+   fields: (t) => ({
+     token: t.string(),
+     user: t.field({ type: UserType }),
+   }),
+ }) 
```

---

Let me create the auth mutations:


---

Cancelled

---

